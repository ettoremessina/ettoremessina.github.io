
<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="it">
	<head>
		<meta http-equiv="content-language" content="it">
		<meta name="author" content="Ettore Messina">

		<style>
			#cookiescript_checkbox_input {
				-moz-appearance: checkbox;
				-webkit-appearance: checkbox;
				-ms-appearance: checkbox;
				appearance: checkbox;
				opacity: 1.0;
			}
			#cookiescript_checkbox_text {
				color: white;
			}
			#cookiescript_description a:hover {
				color: yellow !important;
			}
		</style>
		<script type="text/javascript" charset="UTF-8" src="https://cookie-script.com/s/19e1626ea9f21a6fcc285b559b5957e6.js"></script>
		<script type="text/plain" data-cookiescript="accepted" data-cookiecategory="performance" src="https://www.googletagmanager.com/gtag/js?id=UA-149444322-1"></script>
		<script type="text/plain" data-cookiescript="accepted" data-cookiecategory="performance">
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());
			gtag('config', 'UA-149444322-1', { 'anonymize_ip': true });
		</script>


		<title>Porte quantistiche NOT e C-NOT</title>
		<meta name="description" content="Le porte quantistiche NOT (ovverosia la porta Pauli-X) e C-NOT (controlled-NOT, detto anche XOR quantistico): come funzionano e come usarle" >
		<meta name="keywords" content="not, c-not, cnot, xor, porta, gate, gates, operatore, operatori, qubit, sovrapposizione, entanglement, ibm experience, qiskit, computer quantistico, meccanica quantistica" >
		<link rel="canonical" href="https://computationalmindset.com/it/computazione-quantistica/operatori-not-cnot.html" />
		<link rel="alternate" hreflang="en" href="https://computationalmindset.com/en/quantum-computing/not-cnot-operators.html" />
		<link rel="alternate" hreflang="it" href="https://computationalmindset.com/it/computazione-quantistica/operatori-not-cnot.html" />
		
    <!-- SCHEMA.ORG JSON-LD WEBSITE -->
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "name": "Computational Mindset",
        "url": "https://computationalmindset.com/",
        "sameAs": ["https://www.facebook.com/ComputationalMindset/", "https://www.facebook.com/MentalitaComputazionale/", "https://github.com/ettoremessina/"],
        "author":
        {
          "@type": "Person",
          "name": "Ettore Messina",
          "image": "https://computationalmindset.com/images/ettore-messina.jpg",
          "gender": "Male",          
          "sameAs": ["https://www.facebook.com/ettore.messina.73/", "https://www.instagram.com/etmessina/", "https://twitter.com/ettoremessina/", "https://github.com/ettoremessina/"]
        }
    }
    </script>

		
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement":
        [
		
          {
            "@type": "ListItem",
            "position": 1,
            "item":
            {
                "@id": "https://computationalmindset.com/it/",
                "name": "Mentalit&agrave; Computazionale"
            }
          },
		
          {
            "@type": "ListItem",
            "position": 2,
            "item":
            {
              "@id": "https://computationalmindset.com/it/computazione-quantistica/",
              "name": "Computazione Quantistica"
            }
          },

          {
            "@type": "ListItem",
            "position": 3,
            "item":
            {
              "@id": "https://computationalmindset.com/it/computazione-quantistica/operatori-not-cnot.html",
              "name": "Porte quantistiche NOT e C-NOT"
            }
		  }
		
        ]
    }
    </script>
		

		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/railscasts.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
		
		<script>hljs.initHighlightingOnLoad();</script>
		<style>
			pre > code 
			{
				font-size: 1.2em;
			}
		</style>

		
		<script type="text/javascript" src="https://latex.codecogs.com/latexit.js"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
		</script>
		<script type="text/javascript"
			src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>



		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
		<link rel="icon" href="../../favicon.ico" type="image/x-icon" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../it/info.html" class="logo"><strong>Mentalit&agrave;&nbsp;Computazionale</strong> di&nbsp;Ettore&nbsp;Messina</a>
									<div style="text-align:right">
										<a class="logo" href="../../en/">en</a>
										&nbsp;&nbsp;&nbsp;
										<a class="logo" href="../../it/">it</a>
									</div>
									<ul class="icons">
										<li><a href="https://github.com/ettoremessina/" class="icon brands fa-github" target="_blank"><span class="label">GitHub</span></a></li>
										<li><a href="https://twitter.com/ettoremessina/" class="icon brands fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
										<li><a href="https://www.facebook.com/MentalitaComputazionale/" class="icon brands fa-facebook-f" target="_blank"><span class="label">Facebook</span></a></li>
										<li><a href="https://www.instagram.com/etmessina/" class="icon brands fa-instagram" target="_blank"><span class="label">Instagram</span></a></li>
										<li><a href="https://www.linkedin.com/in/ettoremessina/" class="icon brands fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li>
										<li><a href="https://t.me/ettoremessina/" class="icon brands fa-telegram" target="_blank"><span class="label">Skype</span></a></li>
										<li><a href="https://www.youtube.com/channel/UCKrOtSEJjs5msOhPIdYEeWA/" class="icon brands fa-youtube" target="_blank"><span class="label">YouTube</span></a></li>
										<!--<li><a href="https://medium.com/@ettoremessina/" class="icon brands fa-medium-m" target="_blank"><span class="label">Medium</span></a></li>-->
										<li><a href="skype:ettore-messina?chat" class="icon brands fa-skype" target="_blank"> <span class="label">Skype</span></a></li>
									</ul>
								</header>

<!-- Content -->
	$\newcommand\dag\dagger$
	<section>
		<header class="main">
			<h1>Porte quantistiche NOT e C-NOT</h1>
		</header>

		<p>
			Gli operatori dei tradizionali linguaggi di programmazione di alto livello sono tradotti dai compilatori in brevi sequenze di istruzioni in linguaggio macchina
			e a loro volta tali istruzioni sono implementate all&apos;interno dei microprocessori in microprogrammazione
			le cui microistruzioni utilizzano operatori logici e matematici realizzati direttamente a livello circuitale. <br />
			Ad esempio, in questo frammento di codice in linguaggio C
			<pre><code class="c">int v1, v2;
//….
int v = v1 ^ v2;</code></pre>
			l&apos;espressione <code>v1 ^ v2</code> (cio&egrave; il calcolo <code>v1 xor v2</code> eseguito bit a bit) viene tradotta in assembly x86_64 cos&igrave;:<br />
			<br />
			<pre><code class="asm">mov eax, DWORD PTR [rbp-4]
xor eax, DWORD PTR [rbp-8]
mov DWORD PTR [rbp-12], eax</code></pre>
			La prima istruzione <code>mov</code> copia il valore della variable v1 nel registro eax,
			la seconda istruzione <code>xor</code> esegue l&apos;or esclusivo (lo xor appunto) bit a bit tra il registro eax e la variable v2 e salva il risultato sullo stesso registro eax
			e infine l&apos;ultima istruzione <code>mov</code> assegna il valore del registro eax (che contiene il risultato dello xor bit a bit) alla variable v.<br />
			<br />
			La cosa che viene fatta notare &egrave; che lo <em>xor</em> &egrave; una istruzione implementata direttamente nel microprocessore ed esegue lo xor sui numeri interi a 32 bit (il registro eax contiene 32 bit)
			e che nel processore ci saranno (almeno) 32 microcircuiti che realizzano il calcolo dello xor, ciascun circuito operante (in parallelo e indipendentemente dagli altri) su una coppia di bit (uno proveniente dal registro, l’altro dalla memoria).
			A sua volta ogni microcircuito che calcola lo xor tra due bit &egrave; composto da transistor opportunamente collegati e infine tali transistor sono realizzati sfruttando la fisica dello stato solido che &egrave; alla base dei semiconduttori.<br />
			<br />
			Al di l&agrave; dei tecnicismi, la cosa che si vuole mettere in evidenza &egrave; che un operatore di un linguaggio di alto livello (l&apos;operatore ^ del C in questo esempio) su un processore ordinario
			si appoggia, nel suo livello pi&ugrave; basso di astrazione (inaccessibile allo sviluppatore), sulla fisica dello stato solido 
			poich&eacute; tale &egrave; la fisicit&agrave; dello strato sottostante pi&ugrave; basso (quella dei transistor, appunto).<br />
			<br />
			Un ragionamento simile pu&ograve; essere fatto nella programmazione quantistica: scopo di questo post &egrave; mostrare come due operatori quantistici,
			a partire da un linguaggio di alto livello, sono implementati sfruttando opportuni fenomeni descritti dalla meccanica quantistica.<br />
			In particolare il post mostra i fenomeni quantistici sottostanti gli operatori NOT (pi&ugrave; correttamente chiamato porta Pauli-X) e C-NOT (NOT Controllato, conosciuto anche come <em>xor quantistico</em>).
		</p>

		<h2>Il modello matematico del qubit</h2>
		<p>
			Il qubit &egrave; descritto matematicamente come uno spazio di Hilbert complesso bidimensionale. La base canonica di questo spazio si indica (usando la notazione di Dirac) con
			$$\{|0\rangle,|1\rangle\}$$
			che scritta nella forma della base dei vettori delle componenti &egrave;
			$$\{\begin{bmatrix} 1 \\ 0 \\ \end{bmatrix},\begin{bmatrix} 0 \\ 1 \\ \end{bmatrix}\}$$
			e ciascun elemento della base corrisponde rispettivamente ai bit classici 0 e 1.
			<br/>
			Come per ogni spazio vettoriale, ogni vettore dello spazio pu&ograve; essere scritto univocamente come combinazione lineare dei vettori della base
			$$|\psi\rangle=\alpha|0\rangle + \beta|1\rangle$$
			dove $\alpha$ e $\beta$ si chiamano <em>ampiezze di probabilit&agrave;</em> e devono essere tali che i loro moduli al quadrato (che sono <em>densit&agrave; di probabilit&agrave;</em>)
			debbono soddisfare l&apos;uguaglianza $|\alpha|^2 + |\beta|^2 = 1$<br />
			La meccanica quantistica dice che se si effettua una misura (rispetto alla base) si pu&ograve; soltanto ottenere lo stato $|0\rangle$ (corrispondente al bit 0)
			con probabilit&agrave; $|\alpha|^2$ oppure lo stato $|1\rangle$ (corrispondente al bit 1) con probabilit&agrave; $|\beta|^2$.<br />
		</p>

		<h2>L&apos;operatore NOT</h2>
		<p>
			L&apos;operatore quantistico NOT, che da adesso sar&agrave; chiamato con il suo nome pi&ugrave; appropriato di porta <em>Pauli-X</em> agisce su un singolo qubit
			e il suo scopo &egrave; di invertire il qubit passato rispetto alla base canonica (operazione che corrisponde a una rotazione rispetto all&apos;asse X
			sulla sfera di Bloch, si veda <a href="https://it.wikipedia.org/wiki/Sfera_di_Bloch" target='blank'>Sfera di Bloch su Wikipedia</a>)<br />
			<br />
			Matematicamente bisogna quindi trovare una matrice <em>hermetiana</em> e <em>unitaria</em> (perch&egrave; tutti gli operatori quantistci tali devono essere) 
			che inverta gli stati in maniera tale che:
			$$\alpha|0\rangle + \beta|1\rangle \rightarrow \beta|0\rangle + \alpha|1\rangle$$
			Una tale matrice &egrave;
			$$X=\left[\begin{matrix} 0 & 1 \\ 1 & 0 \end{matrix} \right]$$
			Che la matrice $X$ sia hermetiana &egrave; evidente: essa contiene solo elementi reali ed &egrave; simmetrica.<br />
			&Egrave; unitaria perch&eacute; la sua trasposta coniugata (che &egrave; anche la trasposta essendo presenti solo elementi reali) coincide con la sua inversa
			e la verifica &egrave; un semplice calcolo
			$$XX^\dag=XX=\left[\begin{matrix} 0 & 1 \\ 1 & 0 \end{matrix} \right] \left[\begin{matrix} 0 & 1 \\ 1 & 0 \end{matrix} \right]= \left[\begin{matrix} 1 & 0 \\ 0 & 1 \end{matrix} \right] = I$$
			Analogamente si dimostra che $X^\dag X=I$ per cui vale $X^\dag=X^{-1}$<br />
			<br />
			Dal punto di vista fisico la realizzazione della porta Pauli-X dipende da come il computer quantistico &egrave; realizzato dal punto di vista hardware;
			non &egrave; scopo di questo post entrare nella realizzazione ingegneristica dei qubit, ma giusto per fissare le idee, se ad esempio il qubit fosse realizzato tramite spin di un elettrone,
			la porta Pauli-X sarebbe realizzata provocando una rotazione di $\pi$ intorno all&apos;asse X dello spin dell&apos;elettrone.
		</p>

		<h3>Test della porta Pauli-X su qubit in stato puro</h3>
		<p>
			Si osservi il seguente frammento di codice Python con Qiskit scritto per essere eseguito all&apos;interno di un Jupyter Notebook 
			utilizzando come backend sia il simulatore &apos;qasm_simulator&apos; di IBM che il computer quantistico &apos;ibmq_london&apos; di IBM.
			<pre><code class="python">q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circuit = QuantumCircuit(q, c)

circuit.x(1)
circuit.x(2)
circuit.x(2)

circuit.measure(q, c)</code></pre>
			che corrisponde al seguente circuito quantistico:<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-circuit_1_paulix.png" /></div>
			e il cui risultato eseguito con un numero di shot=8192 sul simulatore IBM &apos;qasm_simulator&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-1-paulix-qiskit_result_sim.png" /></div>
			mentre il risultato eseguito sempre con un numero di shot=8192 sul computer quantistico IBM &apos;ibmq_london&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-1-paulix-qiskit_result_real.png" /></div>
			che &egrave; del tutto equivalente al risultato ottenuto con il simulatore a meno di piccole differenze nella distribuzione delle probabilit&agrave; riconducibili a rumori.<br />
			<br />
			Osservando il risultato possiamo avere la prova sperimentale di quanto affermato sopra riguardo al comportamento della porta Pauli-X
			e possiamo concludere che in assenza di stati di sovrapposizione il comportamento della porta Pauli-X &egrave; del tutto paragonabile
			all&apos;operatore NOT dei linguaggi tradizionali (come ad esempio l&apos;operatore <code>!</code> del C).</br>
			Infatti:
			<ui>
				<li>
					Il qubit 0 non subisce nessuna applicazione di alcun operatore, quindi esso inizia nello stato $|0\rangle$
					e al momento della misura il suo stato vale ovviamente $|0\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Al qubit 1 &egrave; applicata la porta Pauli-X e il comportamento atteso &egrave; infatti quello di un operatore NOT tradizionale:
					porta il qubit dallo stato inziale di $|0\rangle$ allo stato finale di $|1\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Al qubit 2 sono applicate due porte Pauli-X in cascata; anche questa volta il comportamento atteso:
					la prima applicazione porta il qubit dallo stato iniziale di $|0\rangle$ allo stato di $|1\rangle$
					e la seconda applicazione porta il qubit dallo stato di $|1\rangle$ allo stato finale di $|0\rangle$ con probabilit&agrave; del 100%.
					<br />
				</li>
			</ui>
		<p/>
	
		<h3>Test della porta Pauli-X su qubit in sovrapposizione di stati</h3>
		<p>
			La sovrapposizione di stati &egrave; una peculiarit&agrave; dei qubit e non ha una corrispondenza nei bit ordinari.
			Ci si pone infatti la seguente domanda: qual &egrave; il comportamento del qubit in sovrapposizione di stati se a esso viene applicato l&apos;operatore quantistico NOT, ovverosia la porta Pauli-X?<br />
			Si dimostra facilmente che, dato un qubit in sovrapposizione di stati
			$$|\psi\rangle=\alpha|0\rangle + \beta|1\rangle$$
			la porta Pauli-X inverte che ampiezze di probabilit&agrave;, ovverosia il qubit dopo una applicazione della porta Pauli-X si porter&agrave; nello stato 
			$$not |\psi\rangle=\beta|0\rangle + \alpha|1\rangle$$
			La dimostrazione &egrave; la seguente: scrivendo l&apos;applicazione della porta al vettore nella forma dei vettori delle componenti rispetto alla base canonica
			ed eseguendo un passaggio di calcolo
			$$X|\psi\rangle=\left[\begin{matrix} 0 & 1 \\ 1 & 0 \end{matrix} \right] \left[\begin{matrix} \alpha \\ \beta \end{matrix} \right] = \left[\begin{matrix} \beta \\ \alpha \end{matrix} \right] $$
			e tornando nello spazio vettoriale dei qubit si ottiene appunto $\beta|0\rangle + \alpha|1\rangle$, ovverosia l&apos;inversione delle ampiezze di probabilit&agrave;.<br />
			<br />
			Passando al calcolatore, si sarebbe tentati di usare la porta Hadamard per mettere il qubit in una sovrapposizione di stati; ma ai fini dimostrativi non &egrave; molto utile
			in quando applicando la porta Hadamard allo stato $|0\rangle$ accade che $\alpha$ e $\beta$ sono entrambi uguali a $\frac{1}{\sqrt{2}}$
			e l&apos;effetto inversione non si vedrebbe bene. Meglio quindi impostare $\alpha$ e $\beta$ con valori diversi.<br />			

			Si osservi il seguente frammento di codice Python con Qiskit scritto per essere eseguito all&apos;interno di un Jupyter Notebook 
			utilizzando come backend sia il simulatore &apos;qasm_simulator&apos; di IBM che il computer quantistico &apos;ibmq_london&apos; di IBM.
			<pre><code class="python">q = QuantumRegister(1, 'q')
c = ClassicalRegister(1, 'c')
circuit = QuantumCircuit(q, c)

circuit.ucrx([np.pi/3], [], 0)

circuit.measure(q, c)</code></pre>
			che corrisponde al seguente circuito quantistico:<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-circuit_2_paulix.png" /></div>
			e il cui risultato eseguito con un numero di shot=8192 sul simulatore IBM &apos;qasm_simulator&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-2-paulix-qiskit_result_sim.png" /></div>
			mentre il risultato eseguito sempre con un numero di shot=8192 sul computer quantistico IBM &apos;ibmq_london&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-2-paulix-qiskit_result_real.png" /></div>
			<b>Nota</b>: Data la natura stocastica di questo codice, i singoli specifici risultati possono variare. Si consideri di eseguire il codice pi&ugrave; volte.<br />
			<br />
			L&apos;operatore <code>ucrx</code> con argomento $\frac{\pi}{3}$ effettua una rotazione $\theta=\frac{\pi}{3}$ (ovverosia 60°) intorno all&apos;asse $x$ sul qubit 0
			per cui $\alpha=\cos \frac{\theta}{2}=\cos \frac{\frac{\pi}{3}}{2}=\cos \frac{\pi}{6}=\frac{\sqrt{3}}{2}$
			e quindi la densit&agrave; di probabilit&agrave; (che &egrave; il quadrato dell&apos;ampiezza) &egrave; $|\alpha|^2=\frac{3}{4}=0.75$ e necessariamente la densit&agrave; di probabilit&agrave; $|\beta|^2=\frac{1}{4}=0.25$
			e difatti se si va a misurare il qubit 0 si ha una probabilit&agrave; del 75% di ottenere lo stato $|0\rangle$ e del 25% di ottenere $|1\rangle$.<br />
			<br />
			Adesso si modifica il programma aggiungendo una porta Pauli-X a seguire l&apos;applicazione della porta <code>ucrx</code>.
			Qui il codice:<br /><br />
			<pre><code class="python">q = QuantumRegister(1, 'q')
c = ClassicalRegister(1, 'c')
circuit = QuantumCircuit(q, c)

circuit.ucrx([np.pi/3], [], 0)
circuit.x(0)

circuit.measure(q, c)</code></pre>
			che corrisponde al seguente circuito quantistico:<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-circuit_3_paulix.png" /></div>
			e il cui risultato eseguito con un numero di shot=8192 sul simulatore IBM &apos;qasm_simulator&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-3-paulix-qiskit_result_sim.png" /></div>
			mentre il risultato eseguito sempre con un numero di shot=8192 sul computer quantistico IBM &apos;ibmq_london&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-3-paulix-qiskit_result_real.png" /></div>
			da cui si vede chiaramente l&apos;effetto di inversione delle ampiezze di probabilit&agrave; provocato dell&apos;applicazione della porta Pauli-X:
			andando a misurare il qubit 0 si ha una probabilit&agrave; del 25% di ottenere lo stato $|0\rangle$ e del 75% di ottenere $|1\rangle$.<br /><br />
			<b>Nota</b>: Data la natura stocastica di questo codice, i singoli specifici risultati possono variare. Si consideri di eseguire il codice pi&ugrave; volte.<br />
			<br />
			Sopra si era detto che la porta Pauli-X effettua una rotazione di $\pi$ intorno all&apos;asse X della sfera di Bloch:
			programmaticamente l&apos;operatore Pauli-X quindi &egrave; del tutto equivalente allo statement:
			<center><code>circuit.ucrx([np.pi], [], [<em>i</em>])</code></center>
			dove <em>i</em> &egrave; l&apos;indice che qubit che si intende invertire.
		</p>

		<h2>L&apos;operatore C-NOT</h2>
		<p>		
			Facendo di nuovo un parallelo ideale con un linguaggio di programmazione di alto livello, si immagini di avere il seguente frammento di codice C:
			<pre><code class="c">bool control, target;
//….
if (control)
	target = !target;</code></pre>
			il cui senso &egrave; molto semplice: valutare la condizione <em>control</em>, se essa vale true, invertire il valore booleano di <em>target</em>, altrimenti lasciare <em>target</em> inalterato.
			Questo frammento di codice viene tradotto in assembly x86_64 cos&igrave;:<br />
			<br />
			<pre><code class="asm">cmp BYTE PTR [rbp-1], 0
je .L2
xor BYTE PTR [rbp-2], 1
.L2:</code></pre>
		In programmazione classica questo costrutto si chiama NOT condizionato o anche NOT controllato.<br />
		La prima istruzione <code>cmp</code> effettua una comparazione tra il valore della variabile con la costante 0 e imposta a 1 un flag del processore se il confronto d&agrave; esito di uguaglianza,
		altrimenti quel flag viene impostato a 0;
		la seconda istruzione <code>je</code> &egrave; un salto condizionato (nel senso di controllato): salta a L2 se quel flag &egrave; 0 (e quindi se la variabile <em>c</em> vale 0, cio&egrave; false)
		mentre la terza istruzione esegue uno <code>xor</code> tra la variabile <em>b</em> e il valore 1 (e per l&apos;algebra booleana corrisponde a fare un not) e quindi salva il risultato sulla variabile <em>b</em> stessa.<br />
		<br />
		Anche questa volta un costrutto relativamente semplice del linguaggio di alto livello &egrave; implementato con una piccola sequenza di istruzioni in linguaggio macchina
		e a loro volta ogni istruzione, realizzata in microprogammazione, utilizza della circuiteria interna del processore (in questo caso il flag di confronto e il salto condizionato)
		a sua volta costruita con dei semiconduttori (transitor) basati sulla fisica dello stato solido.</br >
		Sui computer quantistici a spin, si &egrave; visto che la porta NOT (o meglio Pauli-X) &egrave; implementata tramite la rotazione dello spin;
		la domanda che ci si pone adesso &egrave; se esiste un meccanismo quantistico di base su cui appoggiarsi per implementare un NOT controllato.<br />
		<br />
		Prima di rispondere a questa domanda &egrave; opportuno entrare nel dettaglio dell&apos;operatore C-NOT dal punto di vista matematico.<br />
		La tabella di verit&agrave; del costrutto NOT controllato su una coppia di bit ordinari &egrave; la seguente:<br />
		<br />
		<center>
			<table class="alt align-center" style="width:300px;">
				<tbody>
					<tr>
						<td class="align-center" colspan="2">input</td>
						<td class="align-center" colspan="2">output</td>
					</tr>
					<tr>
						<td class="align-center">control</td>
						<td class="align-center">target</td>
						<td class="align-center">control</td>
						<td class="align-center">target</td>
					</tr>
					<tr>
						<td class="align-center">0</td>
						<td class="align-center">0</td>
						<td class="align-center">0</td>
						<td class="align-center">0</td>
					</tr>
					<tr>
						<td class="align-center">0</td>
						<td class="align-center">1</td>
						<td class="align-center">0</td>
						<td class="align-center">1</td>
					</tr>
					<tr>
						<td class="align-center">1</td>
						<td class="align-center">0</td>
						<td class="align-center">1</td>
						<td class="align-center">1</td>
					</tr>					
					<tr>
						<td class="align-center">1</td>
						<td class="align-center">1</td>
						<td class="align-center">1</td>
						<td class="align-center">0</td>
					</tr>					
				</tbody>
			</table>
		</center>
		Si osservi che il valore di <em>control</em> di input &egrave; riportato in output inalterato,
		mentre il valore di <em>target</em> &egrave; invertito se <em>control</em> &egrave; <em>1</em> altrimenti resta inalterato.<br />
		<br />		

		La tabella di verit&agrave; del costrutto C-NOT quantistico su una coppia di qubit non in sovrapposizione di stati &egrave; naturalmente la seguente:<br />
		<br />
		<center>
			<table class="alt align-center" style="width:300px;">
				<tbody>
					<tr>
						<td class="align-center" colspan="2">input</td>
						<td class="align-center" colspan="2">output</td>
					</tr>
					<tr>
						<td class="align-center">control</td>
						<td class="align-center">target</td>
						<td class="align-center">control</td>
						<td class="align-center">target</td>
					</tr>
					<tr>
						<td class="align-center">$|0\rangle$</td>
						<td class="align-center">$|0\rangle$</td>
						<td class="align-center">$|0\rangle$</td>
						<td class="align-center">$|0\rangle$</td>
					</tr>
					<tr>
						<td class="align-center">$|0\rangle$</td>
						<td class="align-center">$|1\rangle$</td>
						<td class="align-center">$|0\rangle$</td>
						<td class="align-center">$|1\rangle$</td>
					</tr>
					<tr>
						<td class="align-center">$|1\rangle$</td>
						<td class="align-center">$|0\rangle$</td>
						<td class="align-center">$|1\rangle$</td>
						<td class="align-center">$|1\rangle$</td>
					</tr>					
					<tr>
						<td class="align-center">$|1\rangle$</td>
						<td class="align-center">$|1\rangle$</td>
						<td class="align-center">$|1\rangle$</td>
						<td class="align-center">$|0\rangle$</td>
					</tr>					
				</tbody>
			</table>
		</center>

		Matematicamente la matrice che implementa il C-NOT &egrave; la seguente:
		$$CNOT=\left[\begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{matrix} \right]$$
		Che la matrice $CNOT$ implementi la tabella di verit&agrave; di cui sopra &egrave; evidente e bastano dei semplici calcoli per dimostralo.<br />
		Ad esempio, osservando la penultima voce della tabella, rapprentanto i vettori di input $|1\rangle$ e $|0\rangle$ nella base canonica
		si ottengono i due vettori delle componenti $$\begin{bmatrix} 0 \\ 1 \\ \end{bmatrix} e \begin{bmatrix} 1 \\ 0 \\ \end{bmatrix}$$
		e concatenandoli si ottiene il seguente vettore $$\begin{bmatrix} 0 \\ 1 \\ 1 \\ 0 \\ \end{bmatrix}$$
		e moltiplicando la matrice per questo vettore:
		$$
		\left[\begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{matrix} \right] \begin{bmatrix} 0 \\ 1 \\ 1 \\ 0 \\ \end{bmatrix}
		= \begin{bmatrix} 0 \\ 1 \\ 0 \\ 1 \\ \end{bmatrix}
		$$
		che corrisponde nello spazio vettoriale iniziale alla coppia di vettori ${|1\rangle}$ ${|1\rangle}$ come volevasi dimostrare.<br />
		Analogamente per tutte le altre voci della tabella di verit&agrave; si dimostra che la matrice $CNOT$ implementa effettivamente l&apos;operatore C-NOT.<br />
		<br />

		Affich&eacute; la matrice $CNOT$ sia un valido operatore quantistico deve essere hermetiana e unitaria. Che sia hermetiana &egrave; evidente: essa contiene solo elementi reali ed &egrave; simmetrica.<br />
		&Egrave; unitaria perch&eacute; la sua trasposta coniugata (che &egrave; anche la trasposta essendo presenti solo elementi reali) coincide con la sua inversa
		e la verifica &egrave; un semplice calcolo
		$$CNOT \cdot CNOT^\dag=CNOT \cdot CNOT=\left[\begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{matrix} \right] \left[\begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{matrix} \right]= \left[\begin{matrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{matrix} \right] = I$$
		Analogamente si dimostra che $CNOT^\dag \cdot CNOT=I$ per cui vale $CNOT^\dag=CNOT^{-1}$
		<br />
		&Egrave; arrivato il momento di rispondere alla domanda pendente, cio&egrave; se esiste un fenomeno quantistico su cui realizzare il costrutto C-NOT;
		infatti il grande vantaggio della computazione quantistica rispetto alla computazione tradizionale &egrave; quello di poter applicare gli operatori ai qubit quando questi si trovano in una sovrapposizione di stati;
		affinch&eacute; l&apos;operatore C-NOT sia applicabile ai qubit in tale situazione senza effettuare alcuna misurazione (che farebbe collassare in qubit in uno stato puro), esso deve essere realizzato nativamente sfruttando un qualche fenomeno quantistico che coinvolga due qubit:
		tale fenomeno esiste, e si chiama chiama <i>entanglement</i> (per approfondimenti si veda <a href="https://it.wikipedia.org/wiki/Entanglement_quantistico" target='blank'>Entanglement quantistico su Wikipedia</a>)
		</p>

		<h3>Test della porta C-NOT su qubit in stati puri</h3>
		<p>
			Si osservi il seguente frammento di codice Python con Qiskit scritto per essere eseguito all&apos;interno di un Jupyter Notebook 
			utilizzando come backend sia il simulatore &apos;qasm_simulator&apos; di IBM che il computer quantistico &apos;ibmq_london&apos; di IBM.
			<pre><code class="python">q = QuantumRegister(4, 'q')
c = ClassicalRegister(4, 'c')
circuit = QuantumCircuit(q, c)

circuit.cx(0, 1)
circuit.x(3)
circuit.cx(2, 3)

circuit.measure(q, c)
</code></pre>
			che corrisponde al seguente circuito quantistico:<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-circuit_1_cnot.png" /></div>
			e il cui risultato eseguito con un numero di shot=8192 sul simulatore IBM &apos;qasm_simulator&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-1-cnot-qiskit_result_sim.png" /></div>
			mentre il risultato eseguito sempre con un numero di shot=8192 sul computer quantistico IBM &apos;ibmq_london&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-1-cnot-qiskit_result_real.png" /></div>
			che &egrave; del tutto equivalente al risultato ottenuto con il simulatore a meno di piccole differenze nella distribuzione delle probabilit&agrave; riconducibili a rumori.<br />
			<br />
			Osservando il risultato possiamo avere la prova sperimentale di quanto affermato sopra riguardo al comportamento della porta C-NOT
			per quanto riguarda le prime due voci della tabella di verit&agrave; mostrata sopra:
			infatti l&apos;input ai 4 qubit corrisponde agli input delle prime due voci della tabella, (${|0\rangle}$ e ${|0\rangle}$ per la prima riga e ${|0\rangle}$ e ${|1\rangle}$ per la seconda riga)
			e per quanto riguarda l&apos;output vale quanto segue:
			<ui>
				<li>
					Il qubit 0 &egrave; il control del qubit 1 e non subisce alcuna variazione quindi esso inizia nello stato $|0\rangle$
					e al momento della misura il suo stato vale ovviamente $|0\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Il qubit 1 &egrave; in entanglement con il qubit 0 per cui il qubit 0 &egrave; il control e il qubit 1 &egrave; il target;
					il comportamento atteso &egrave; infatti quello di un operatore C-NOT tradizionale nel caso del bit control uguale a 0 (quindi il target non cambia valore):
					infatti il qubit 1 dallo stato inziale di $|0\rangle$ rimane nello stato finale di $|0\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Il qubit 2 &egrave; il control del qubit 3 e non subisce alcuna variazione quindi esso inizia nello stato $|0\rangle$
					e al momento della misura il suo stato vale ovviamente $|0\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Il qubit 3 &egrave; in entanglement con il qubit 2 per cui il qubit 2 &egrave; il control e il qubit 3 &egrave; il target;
					il comportamento atteso &egrave; infatti quello di un operatore C-NOT tradizionale nel caso del bit control uguale a 0 (quindi il target non cambia valore):
					infatti il qubit 1 dallo stato inziale di $|1\rangle$ rimane stato finale di $|1\rangle$ con probabilit&agrave; del 100%.
				</li>
			</ui>
		</p>
		<p>
			Il seguente frammento di codice:
			<pre><code class="python">q = QuantumRegister(4, 'q')
c = ClassicalRegister(4, 'c')
circuit = QuantumCircuit(q, c)

circuit.x(0)
circuit.cx(0, 1)

circuit.x(2)
circuit.x(3)
circuit.cx(2, 3)

circuit.measure(q, c)
</code></pre>
			che corrisponde al seguente circuito quantistico:<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-circuit_2_cnot.png" /></div>
			e il cui risultato eseguito con un numero di shot=8192 sul simulatore IBM &apos;qasm_simulator&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-2-cnot-qiskit_result_sim.png" /></div>
			mentre il risultato eseguito sempre con un numero di shot=8192 sul computer quantistico IBM &apos;ibmq_london&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-2-cnot-qiskit_result_real.png" /></div>
			che &egrave; del tutto equivalente al risultato ottenuto con il simulatore a meno di piccole differenze nella distribuzione delle probabilit&agrave; riconducibili a rumori.<br />
			<br />
			Osservando il risultato possiamo avere la prova sperimentale di quanto affermato sopra riguardo al comportamento della porta C-NOT
			per quanto riguarda le ultime due righe della tabella di verit&agrave; mostrata sopra:
			infatti l&apos;input ai 4 qubit corrisponde agli input delle ultime due voci della tabella, (${|1\rangle}$ e ${|0\rangle}$ per la penultima riga e ${|1\rangle}$ e ${|1\rangle}$ per l&apos;ultima riga)
			e per quanto riguarda l&apos;output vale quanto segue:
			<ui>
				<li>
					Il qubit 0 &egrave; il control del qubit 1 e non subisce alcuna variazione quindi esso inizia nello stato $|1\rangle$
					e al momento della misura il suo stato vale ovviamente $|1\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Il qubit 1 &egrave; in entanglement con il qubit 0 per cui il qubit 0 &egrave; il control e il qubit 1 &egrave; il target;
					il comportamento atteso &egrave; infatti quello di un operatore C-NOT tradizionale nel caso del bit control uguale a 1 (quindi il target inverte il valore):
					infatti il qubit 1 dallo stato inziale di $|1\rangle$ cambia stato finale di $|0\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Il qubit 2 &egrave; il control del qubit 3 e non subisce alcuna variazione quindi esso inizia nello stato $|1\rangle$
					e al momento della misura il suo stato vale ovviamente $|1\rangle$ con probabilit&agrave; del 100%.
				</li>
				<li>
					Il qubit 3 &egrave; in entanglement con il qubit 2 per cui il qubit 2 &egrave; il control e il qubit 3 &egrave; il target;
					il comportamento atteso &egrave; infatti quello di un operatore C-NOT tradizionale nel caso del bit control uguale a 1 (quinid il target inverte il valore):
					infatti il qubit 3 dallo stato inziale di $|1\rangle$ cambia stato finale in $|0\rangle$ con probabilit&agrave; del 100%.
				</li>
			</ui>			
			<br />
			&Egrave; possibile quindi concludere che in assenza di stati di sovrapposizione il comportamento della porta C-NOT &egrave; del tutto paragonabile
			al costrutto NOT-controllato dei linguaggi tradizionali.</br>
		<p/>

		<h3>Test della porta C-NOT con sovrapposizione</h3>
		<p>
			Ci si pone adesso la seguente domanda: qual &egrave; il comportamento della porta C-NOT applicata a due qubit in sovrapposizione di stati?<br />
			Dati due qubit, il primo di <em>control</em> e il secondo di <em>target</em> in entanglement e in sovrapposizione di stati
			$$q _0=\alpha|0\rangle + \beta|1\rangle$$
			$$q _1=\gamma|0\rangle + \delta|1\rangle$$
			e si effettui una rotazione di $\theta=\frac{\pi}{3}$ (ovverosia 60°) intorno all&apos;asse $x$ sul qubit 0 e quindi $\alpha=\cos \frac{\theta}{2}=\cos \frac{\frac{\pi}{3}}{2}=\cos \frac{\pi}{6}=\frac{\sqrt{3}}{2}$
			e quindi la densit&agrave; di probabilit&agrave; $|\alpha|^2=\frac{3}{4}=0.75$ e necessariamente la densit&agrave; di probabilit&agrave; $|\beta|^2=\frac{1}{4}=0.25$.<br />
			Si effettui inoltre una rotazione di $\theta=\frac{\pi}{6}$ (ovverosia 30°) intorno all&apos;asse $x$ sul qubit 1 e quindi $\gamma=\cos \frac{\theta}{2}=\cos \frac{\frac{\pi}{6}}{2}=\cos \frac{\pi}{12}=\frac{\sqrt{6} + \sqrt{2}}{4}$
			e quindi la densit&agrave; di probabilit&agrave; $|\gamma|^2=\frac{2 + \sqrt{3}}{4} \simeq 0.933013$ e necessariamente l&apos;ampiezza di probabilit&agrave; $|\delta|^2=\frac{2 + \sqrt{3}}{4} \simeq 0.0669873$.
			<br />
			Passando al calcolatore, si osservi il seguente frammento di codice Python con Qiskit scritto per essere eseguito all&apos;interno di un Jupyter Notebook 
			utilizzando come backend sia il simulatore &apos;qasm_simulator&apos; di IBM che il computer quantistico &apos;ibmq_london&apos; di IBM.
			<pre><code class="python">q = QuantumRegister(2, 'q')
c = ClassicalRegister(2, 'c')
circuit = QuantumCircuit(q, c)

circuit.ucrx([np.pi/3], [], 0)
circuit.ucrx([np.pi/6], [], 1)
circuit.cx(0, 1)

circuit.measure(q[1], c[1])
</code></pre>
			che corrisponde al seguente circuito quantistico:<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-circuit_3_cnot.png" /></div>
			e il cui risultato eseguito con un numero di shot=8192 sul simulatore IBM &apos;qasm_simulator&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-3-cnot-qiskit_result_sim.png" /></div>
			mentre il risultato eseguito sempre con un numero di shot=8192 sul computer quantistico IBM &apos;ibmq_london&apos; &egrave; il seguente:<br />
			<br />
			<div class="betweentextlines"><img src="../../posts/quantum-computing/not-cnot-operators/qc-notcnoto-src-3-cnot-qiskit_result_real.png" /></div>
			<b>Nota</b>: Data la natura stocastica di questo codice, i singoli specifici risultati possono variare. Si consideri di eseguire il codice pi&ugrave; volte.<br />
			<br />
			L&apos;output del programma consiste nella misura del qubit 1 (il target): la probabilit&agrave; di ottenere $|0\rangle$ sul qubit 1 in uscita &egrave; data dalla somma della prima e quarta riga della tabella di verit&agrave.
			<br />
			La probabilit&agrave; della prima riga &egrave; data dal prodotto della probabilit&agrave; del qubit 0 di essere $|0\rangle$ (che sappiamo essere 0.75) per la probabilit&agrave; del qubit 1 di essere $|0\rangle$ (che sappiamo essere circa $0.933013$)
			e quindi circa $0.699760$.<br />
			<br />
			La probabilit&agrave; della quarta riga &egrave; data dal prodotto della probabilit&agrave; del qubit 0 di essere $|1\rangle$ (che sappiamo essere 0.25) per la probabilit&agrave; del qubit 1 di essere $|1\rangle$ (che sappiamo essere circa $0.066987$)
			e quindi circa $0.016746$.<br />
			Sommando le due probabilit&agrave; si calcola la probabilit&agrave; di ottenere $|0\rangle$ sul qubit 1 in uscita che &egrave; quindi $0.699760 + 0.016746 = 0.716220$ che &egrave; quanto ottenuto sperimentalmente (a meno di piccoli scostamenti dovuta alla natura stocastica).
			Analogamente si calcola che la probabilit&agrave; di ottenere $|1\rangle$ sul qubit 1 in uscita &egrave; pari a $0.283780$, assai vicina alla probabilit&agrave; determinata sperimentalmente.
		</p>

		<h2>Download del codice completo</h2>
		<p>
			Il codice completo &egrave; disponibile su <a target="_blank" href="https://github.com/ettoremessina/quantum-experiments/tree/master/QuantumGates/NotCNotGates">GitHub</a>.
			<br/>
			
			Questo materiale &egrave; distribuito su licenza MIT; sentiti libero di usare, condividere, &quot;forkare&quot; e adattare tale materiale come credi.
			<br/>
			Sentiti anche libero di pubblicare pull-request e bug-report su questo repository di GitHub oppure di contattarmi sui miei canali social disponibili nell&apos;angolo in alto a destra di questa pagina. 
			<br/>

		</p>
	</section>

						</div>
				</div>
				<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">
							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<div class="align-center"><img src="../../images/cm-logo-small.png" alt="Mentalit&agrave;&nbsp;Computazionale"/></div>
										<h2>Menu</h2>
									</header>
									<ul>
										<li><a href="../../it/">Home</a></li>
										<li>
											<span class="opener">Reti&nbsp;Neurali</span>
											<ul>
												<li><a href="../../it/reti-neurali/">INDICE</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-con-percettroni-multistrato-altamente-configurabili.html">Approssimazione con percettroni multistrato altamente configurabili</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-funzione-reale-di-una-variabile-con-tensorflow.html">Approssimazione di una funzione reale di una variabile con TensorFlow</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-funzione-reale-di-una-variabile-con-pytorch.html">Approssimazione di una funzione reale di una variabile con PyTorch</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-curva-sul-piano-con-tensorflow.html">Approssimazione di una curva parametrica su un piano con TensorFlow</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-curva-sul-piano-con-pytorch.html">Approssimazione di una curva parametrica su un piano con PyTorch</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-curva-nello-spazio-con-tensorflow.html">Approssimazione di una curva parametrica nello spazio con TensorFlow</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-curva-nello-spazio-con-pytorch.html">Approssimazione di una curva parametrica nello spazio con PyTorch</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-funzione-reale-di-due-variabili-con-tensorflow.html">Approssimazione di una funzione reale di due variabili con TensorFlow</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-di-una-funzione-reale-di-due-variabili-con-pytorch.html">Approssimazione di una funzione reale di due variabili con PyTorch</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Computazione&nbsp;Quantistica</span>
											<ul>
												<li><a href="../../it/computazione-quantistica/">INDICE</a></li>
												<li><a href="../../it/computazione-quantistica/operatori-not-cnot.html">Porte quantistiche NOT e C-NOT</a></li>
												<li><a href="../../it/computazione-quantistica/generazione-numero-casuale.html">Generazione di un numero casuale</a></li>
												<li><a href="../../it/computazione-quantistica/porte-hadamard-in-cascata.html">Porte Hadamard in cascata</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Machine&nbsp;Learning</span>
											<ul>
												<li><a href="../../it/machine-learning/">INDICE</a></li>
												<li><a href="../../it/machine-learning/regressione-polinomiale-con-accord-net.html">Regressione polinomiale con Accord.NET</a></li>
												<li><a href="../../it/machine-learning/regressione-smo-con-kernel-puk-in-weka.html">Regressione con SMO per SVM con kernel PUK in Weka</a></li>
												<li><a href="../../it/machine-learning/forecast-smo-con-kernel-polinomiale-in-weka.html">Forecast con SMO per SVM con kernel polinomiale in Weka</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Dataset</span>
											<ul>
												<li><a href="../../it/datasets/">INDICE</a></li>
												<li><a href="../../it/datasets/functions-dataset.html">Collezione di dataset &apos;Functions&apos;</a></li>
												<li><a href="../../it/datasets/time-series-dataset.html">Collezione di dataset &apos;Time&nbsp;Series&apos;</a></li>
												<li><a href="../../it/datasets/synthetic-words-dataset.html">Dataset &apos;Synthetic Words&apos;</a></li>
											</ul>
										</li>
										<li><a href="../../it/info.html">Info</a></li>
									</ul>
								</nav>

							<!-- Section -->
								<section>
                                    <div class="side-topics">
                                        <header class="align-center">
                                            <h2><a href="../../it/reti-neurali/">Reti&nbsp;Neurali</a></h2>
                                        </header>
                                        <article>
                                            <a href="../../it/reti-neurali/" class="image"><span class="icon solid fa-sitemap"/></a>
                                        </article>
                                        <header class="align-center">
                                            <h2><a href="../../it/computazione-quantistica/">Computazione&nbsp;Quantistica</a></h2>
                                        </header>
                                        <article>
                                            <a href="../../it/computazione-quantistica/" class="image"><span class="icon solid fa-atom"/></a>
                                        </article>
                                    </div>
								</section>

							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">
										Grafica basata sul template &apos;Editorial&apos; (con personalizzazione) scaricato da <a href="https://html5up.net" target="_blank">HTML5 UP</a>.
										<br/>
										Clicka sui link per vedere i file <a href="../../html5up-license/LICENSE.txt" target="_blank">LICENSE.txt</a> e <a href="../../html5up-license/README.txt" target="_blank">README.txt</a> del template &apos;Editorial&apos; di HTML5 UP.
										<br>
										<br>
										&copy; <a href="../../en/info.html">Ettore Messina</a>. 
									</p>
								</footer>
						</div>
					</div>
			</div>

		<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/browser.min.js"></script>
			<script src="../../assets/js/breakpoints.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<script src="../../assets/js/main.js"></script>

			<style>
				a.cc-link
				{
			    	border-bottom: none;
				}
				a.cc-link:hover
				{
					color: white !important;
				}
			</style>
	</body>
</html>

