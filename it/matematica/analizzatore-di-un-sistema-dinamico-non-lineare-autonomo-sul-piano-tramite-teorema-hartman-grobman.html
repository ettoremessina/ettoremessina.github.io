
<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="it">
	<head>
		<meta http-equiv="content-language" content="it">
		<meta name="author" content="Ettore Messina">

		<style>
			#cookiescript_checkbox_input {
				-moz-appearance: checkbox;
				-webkit-appearance: checkbox;
				-ms-appearance: checkbox;
				appearance: checkbox;
				opacity: 1.0;
			}
			#cookiescript_checkbox_text {
				color: white;
			}
			#cookiescript_description a:hover {
				color: yellow !important;
			}
		</style>
		<script type="text/javascript" charset="UTF-8" src="https://cookie-script.com/s/19e1626ea9f21a6fcc285b559b5957e6.js"></script>


		<title>Analizzatore di un sistema dinamico non lineare e autonomo sul piano tramite il teorema di Hartman-Grobman</title>
		<meta name="description" content="Il post mostra un programma scritto in Python che, applicando il teorema di Hartman-Grobman, studia il comportamento di un sistema dinamico non lineare e autonomo sul piano e ne traccia il ritratto delle fasi." >
		<meta name="keywords" content="Hartman, Grobman, sistema dinamico, sistemi dinamici, non lineare, equazioni differenziali, piano, autovalori, autovettori, stabilit&agrave;, punto critico, stazionario, equilibrio, Lotka, Volterra, Holling, Tanner" >
		<link rel="canonical" href="https://computationalmindset.com/it/matematica/analizzatore-di-un-sistema-dinamico-non-lineare-autonomo-sul-piano-tramite-teorema-hartman-grobman.html" />
		<link rel="alternate" hreflang="en" href="https://computationalmindset.com/en/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem.html" />
		<link rel="alternate" hreflang="it" href="https://computationalmindset.com/it/matematica/analizzatore-di-un-sistema-dinamico-non-lineare-autonomo-sul-piano-tramite-teorema-hartman-grobman.html" />
		
    <!-- SCHEMA.ORG JSON-LD WEBSITE -->
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "name": "Computational Mindset",
        "url": "https://computationalmindset.com/",
        "sameAs": ["https://www.facebook.com/ComputationalMindset/", "https://github.com/ettoremessina/"],
        "author":
        {
          "@type": "Person",
          "name": "Ettore Messina",
          "image": "https://computationalmindset.com/images/ettore-messina.jpg",
          "gender": "Male",          
          "sameAs": ["https://www.facebook.com/ettore.messina.73/", "https://www.instagram.com/etmessina/", "https://twitter.com/ettoremessina/", "https://twitter.com/Computational_M/", "https://github.com/ettoremessina/", "https://medium.com/@ettoremessina/", "https://www.linkedin.com/in/ettoremessina", "https://www.linkedin.com/company/computational-mindset", "https://ettoremessina.tech/"]
        }
    }
    </script>

		
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement":
        [
		
          {
            "@type": "ListItem",
            "position": 1,
            "item":
            {
                "@id": "https://computationalmindset.com/it/",
                "name": "Mentalit&agrave; Computazionale"
            }
          },
		
          {
            "@type": "ListItem",
            "position": 2,
            "item":
            {
              "@id": "https://computationalmindset.com/it/matematica/",
              "name": "Matematica"
            }
          },

          {
            "@type": "ListItem",
            "position": 3,
            "item":
            {
              "@id": "https://computationalmindset.com/it/matematica/analizzatore-di-un-sistema-dinamico-non-lineare-autonomo-sul-piano-tramite-teorema-hartman-grobman.html",
              "name": "Analizzatore di un sistema dinamico non lineare e autonomo sul piano tramite il teorema di Hartman-Grobman"
            }
		  }
		
        ]
    }
    </script>
		

		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/railscasts.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
		
		<script>hljs.initHighlightingOnLoad();</script>
		<style>
			pre > code 
			{
				font-size: 1.2em;
			}
		</style>

		
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
		</script>
		<script type="text/javascript"
			src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>

		<!-- OPEN GRAPH PROTOCOL --------------------------------------------------------------------->
		<meta property="og:url" content="https://computationalmindset.com/it/matematica/analizzatore-di-un-sistema-dinamico-non-lineare-autonomo-sul-piano-tramite-teorema-hartman-grobman.html" />
		<meta property="og:type" content="article" />
		<meta property="og:title" content="" />
		<meta property="og:description" content="" />
		<meta property="og:image" content="/social-previews/thumbnail15.jpg" />
		<!-- OPEN GRAPH PROTOCOL --------------------------------------------------------------------->


		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
		<link rel="icon" href="../../favicon.ico" type="image/x-icon" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../it/info.html" class="logo"><strong>Mentalit&agrave;&nbsp;Computazionale</strong> di&nbsp;Ettore&nbsp;Messina</a>
									<div style="text-align:right">
										<a class="logo" href="../../en/">en</a>
										&nbsp;&nbsp;&nbsp;
										<a class="logo" href="../../it/">it</a>
									</div>
									<ul class="icons">
										<li><a href="https://github.com/ettoremessina/" class="icon brands fa-github" target="_blank"><span class="label">GitHub</span></a></li>
										<li><a href="https://www.linkedin.com/company/computational-mindset" class="icon brands fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li>
										<li><a href="https://twitter.com/Computational_M/" class="icon brands fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
										<li><a href="https://www.facebook.com/ComputationalMindset/" class="icon brands fa-facebook-f" target="_blank"><span class="label">Facebook</span></a></li>
										<li><a href="https://www.youtube.com/c/ComputationalMindset" class="icon brands fa-youtube" target="_blank"><span class="label">YouTube</span></a></li>
										<li><a href="https://linktr.ee/ComputationalMindset/" class="fas fa-link" style="color: grey;" target="_blank"><span class="label"></span></a></li>
										<li><a href="https://ettoremessina.tech/" class="icon brands fa-wordpress" target="_blank"><span class="label">WordPress</span></a></li>
									</ul>
								</header>

<!-- Content -->
    $\newcommand{\dee}{\mathop{\mathrm{d}\!}}$
	$\newcommand\dag\dagger$
	<section>
		<header class="main">
			<h1>Analizzatore di un sistema dinamico non lineare e autonomo sul piano tramite il teorema di Hartman-Grobman</h1>
		</header>
		<p>
			Questo post presenta il programma Python <code><a href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer.py" target="_blank">nonlin-auton-plane-sys-hartman-analyzer.py</a></code> e la sua usage in linea di comando.
			Il programma analizza, utilizzando sia tecniche simboliche (tramite SymPy) che tecniche numeriche (tramite NumPy),
			il comportamento di un sistema dinamico non lineare e autonomo sul piano
			definito da un sistema di due equazioni differenziali:
			
            $$ \begin{equation}
            \begin{cases}
                x&apos;(t) = P(x, y)
                \\
                y&apos;(t) = Q(x, y)
            \end{cases}
            \end{equation} $$
<br />
			dove $P$ e $Q$ sono due funzioni non lineari di $x$ e $y$.<br />
			<br />		
			Il programma dapprima determina i punti critici e se essi siano in numero finito (il programma non supporta un numero infitino di punti critici),
			determina se essi siano iperbolici o non iperbolici analizzando gli autovalori e gli autovettori della matrice jacobiana calcolata in ciascun punto critico;
			poi solamente per i punti critici iperbolici il programma li classifica nella opportuna categoria
			analizzando la tipologia e la stabilit&agrave; del sistema lineare ottenuto applicando il teorema di <a target="_blank" href="https://it.wikipedia.org/wiki/Teorema_di_Hartman-Grobman">teorema di Hartman-Grobman</a>.<br />
			Infine il programma traccia anche il <em>ritratto delle fasi</em> sul piano che fornisce una analisi qualitativa del comportamento delle traiettorie
			su cui disegna anche gli autovettori (qualora essi non siano complessi) delle matrici a coefficienti costanti che rappresentano i sistemi linearizzati nei punti critici iperbolici.<br />
			<br />
			Fondamentalmente il teorema di Hartman-Grobman dimostra che il comportamento di un sistema dinamico nell&apos;intorno di un punto critico iperbolico
			&egrave; qualitativamente simile a quello della sua linearizzazione intorno a quel punto e ne fornisce la formula di linearizzazione che &egrave; basata
			sulla matrice jacobiana del sistama originale calcolata in tale punto critico.
			Per cui studiando tale linearizzazione, che &egrave; pi&ugrave; agevole, si possono studiare indirettamente alcune caratteristiche del sistema originale.<br />
			<br />
			Si ringrazia la prof.ssa Fausta D&apos;Acunzo di <a href="https://youtube.com/c/Preparazione20" target="_blank">Preparazione 2.0</a> per il supporto teorico fornito sui sistemi non lineari e autonomi di equazioni differenziali.<br />
			<br />
			Per ottenere il codice si veda il paragrafo <a href="#downloadcode">Download del codice completo</a> in fondo a questo post.<br/>
			<br />
			Per un approfondimento sullo studio dei sistemi lineari e omogenei sul piano a coefficienti costanti si veda il post
			<a href="../../it/matematica/analizzatore-di-un-sistema-dinamico-sul-piano-lineare-omogeneo-coefficienti-costanti.html">Analizzatore di un sistema dinamico, lineare e omogeneo sul piano a coefficienti costanti</a> pubblicato sempre su questo sito web.<br />
        </p>

        <h2>Convenzioni</h2>
        <p>
            In questo post le convenzioni adoperate sono le seguenti:
            <ul>
                <li>$t$ &egrave; la variabile indipendente tempo.</li>
                <li>$x(t)$ e $y(t)$ sono le due funzioni incognite del sistema.</li>
				<li>$J$ indica la matrice jacobiana.</li>
				<li>$J_{(x_i, y_i)}$ indica la matrice jacobiana calcolata nel punto $\left[\begin{matrix} x_i & y_i \end{matrix} \right]^\dag$.</li>
				<li>$\lambda_{i_1}$ e $\lambda_{i_2}$ sono i due autovalori della matrice $J_{(x_i, y_i)}$.</li>
            </ul>
        </p>

        <h2>Definizioni</h2>
        <p>
            In questo post valgono le seguenti definizioni:
			<ul>
				<li>
					<b>Sistema autonomo</b>: un sistema di equazioni differenziali ordinarie che non dipendono esplicitamente dalla variabile indipendente $t$.<br />
					<br />
				</li>
				<li>
					<b>Punto critico</b>: un punto dove $\frac{dx}{dt}$ e $\frac{dy}{dt}$ calcolati in tale punto siano uguali a $0$ per ogni $t$.<br />
					<br />
				</li>
				<li>
					<b>Punto stazionario o di equilibrio</b>: un punto critico che sia di minimo relativo o di massimo relativo, e non invece un punto di sella.<br />
					<br />
				</li>
				<li>
					<b>Matrice jacobiana</b>: &egrave; la matrice 2x2 i cui elementi sono le derivate parziali prime delle funzioni $P(x, y)$ e $Q(x, y)$ rispetto a $x$ e $y$.<br />
					<br />
				</li>
				<li>
					<b>Punto iperbolico</b>: un punto critico $\left[\begin{matrix} x_i & y_i \end{matrix} \right]^\dag$ tale che
					la matrice $J_{(x_i, y_i)}$ che linearizza il sistema iniziale in tale punto critico non abbia autovalori con parte reale uguale a $0$.<br />
					La parola &quot;iperbolico&quot; &egrave; dovuta al fatto che sul piano le traiettorie vicine al punto iperbolico giacciono su tratti di iperbole centrate in tal punto
					rispetto ad un opportuno sistema di riferimento.<br />
					<br />
				</li>
				<li>
					<b>Punto non iperbolico</b>: un punto critico $\left[\begin{matrix} x_i & y_i \end{matrix} \right]^\dag$ tale che
					la matrice $J_{(x_i, y_i)}$ che linearizza il sistema iniziale in tale punto critico abbia autovalori uguali a zero oppure immaginari puri (quindi con parte reale uguale a $0$).<br />
					<br />
				</li>
			</ul>			
        </p>

        <h2>Funzionalit&agrave; del programma</h2>
        <p>
			Il programma prende in input, tramite linea di comando, la coppia di funzioni non lineari $P(x,y)$ e $Q(x,y)$
			che rappresentano il sistema da studiare nella forma:
			
            $$ \begin{equation}
            \begin{cases}
                x&apos;(t) = P(x, y)
                \\
                y&apos;(t) = Q(x, y)
            \end{cases}
            \end{equation} $$
<br />
			e ne determina le seguenti caratteristiche:
			<ul>
				<li>
					<b>L&apos;insieme dei punti critici</b>, risolvendo il sistema di equazioni:
					
            $$ \begin{equation}
            \begin{cases}
                P(x, y) = 0
                \\
                Q(x, y) = 0
            \end{cases}
            \end{equation} $$

					Se i punti critici sono infiniti, il programma non effettua altre elaborazioni e salta a disegnare il ritratto delle fasi.
				</li>

				<li>
					<b>La tipologia dei punti critici</b>, divisi tra <em>iperbolici</em> vs <em>non iperbolici</em> studiando la parte reale degli autovalori
					della matrice jacobiana calcolata per ogni punto critico: se la parte reale &egrave; diversa da zero,
					il punto &egrave; di tipo iperbolico, altrimenti (quindi almeno un autovalore &egrave uguale a zero oppure un immaginario puro)
					il punto &egrave; di tipo non iperbolico.
				</li>

				<li>
					<b>Gli autovalori e gli autovettori della matrice jacobiana $J_{(x_i, y_i)}$</b>, distinguendo i vari casi tra reali vs complessi, segno (della parte reale) concorde o discorde,
					casi degenere (molteplicit&agrave; geometrica minore di 2);
					in questo ultimo caso il programma calcola gli autovettori generalizzati tramite un algoritmo basato sui blocchi di Jordan.
				</li>

				<li>
					<b>La classe dei punti critici iperbolici</b>, divisi tra <em>stabile</em> vs <em>instabile</em> e tra <em>nodo</em>, <em>punto</em>, <em>sella</em>, <em>singolare</em>, <em>degenere</em>
					ed eventuali loro combinazioni in funzione del segno degli autovalori della matrice jacobiana calcolata per ogni punto critico iperbolico.
				</li>
			</ul>
			Inoltre il programma traccia il ritratto delle fasi, che contiene:
			<ul>
				<li><b>Le traiettorie</b>, tracciate in rosso e calcolate risolvendo numericamente il sistema di equazioni differenziali variando in modo discreto la condizione iniziale al tempo $t=0$.</li>
				<li><b>Il gradiente</b>, tracciato come campo vettoriale con frecce di colore blu; la lunghezza delle frecce indica il valore del modulo del gradiente,
				il verso indica la direzione in cui il vettore gradiente tende a $\mathbf{0}$.</li>
				<li><b>Gli autovettori</b>, disegnati solo se hanno le componenti reali; un autovettore corrispondente a un autovalore positivo &egrave; disegnato con una freccia color magenta,
				un autovettore corrispondente a un autovalore negativo &egrave; disegnato con una freccia color verde.</li>
			</ul>
        <p>

        <h2>L&apos;usage del programma</h2>
        <p>
			Per ottenere l&apos;usage del programma <code><a href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer.py" target="_blank">nonlin-auton-plane-sys-hartman-analyzer.py</a></code> &egrave; sufficiente eseguire il seguente comando:
			<pre><code class="shell">$ python nonlin-auton-plane-sys-hartman-analyzer.py --help</code></pre>
			e l&apos;output ottenuto &egrave;:
			<br/>
			<br/>
			<pre><code class="shell">usage: nonlin-auton-plane-sys-hartman-analyzer.py [-h] [--version] --dx_dt
                    FUNC_DX_DT_BODY --dy_dt
                    FUNC_DY_DT_BODY
                    [--t_end T_END]
                    [--t_num_of_samples T_NUM_OF_SAMPLES]
                    [--x0_begin X0_BEGIN]
                    [--x0_end X0_END]
                    [--x0_num_of_samples X0_NUM_OF_SAMPLES]
                    [--y0_begin Y0_BEGIN]
                    [--y0_end Y0_END]
                    [--y0_num_of_samples Y0_NUM_OF_SAMPLES]
                    [--font_size FONT_SIZE]

nonlin-auton-plane-sys-hartman-analyzer.py analyzes a dynamyc system modeled
by a nonlinear planar system using Hartman theorem

optional arguments:
  -h, --help            show this help message and exit
  --version             show program's version number and exit
  --dx_dt FUNC_DX_DT_BODY
                        dx/dt=P(x, y) body (lamba format)
  --dy_dt FUNC_DY_DT_BODY
                        dy/dt=Q(x, y) body (lamba format)
  --t_end T_END         In the phase portait diagram, it is the final value
                        of the interval of variable t (starting value of t is 0).
                        For backward time trajectories, t goes from -t_end to 0;
                        for forward time trajectories, t goes from 0 to t_end.
  --t_num_of_samples T_NUM_OF_SAMPLES
                        In the phase portait diagram, it is the number of samples
                        of variable t between -t_end and 0
                        for backward time trajectories
                        and also it is the number of samples of variable t
                        between 0 and t_end for forward time trajectories
  --x0_begin X0_BEGIN   In the phase portait diagram, it is the starting
                        value of the interval of initial condition x0
  --x0_end X0_END       In the phase portait diagram, it is the final
                        value of the interval of initial condition x0
  --x0_num_of_samples X0_NUM_OF_SAMPLES
                        In the phase portait diagram, it is the number of samples
                        of initial condition x0 between x0_begin and x0_end
  --y0_begin Y0_BEGIN   In the phase portait diagram, it is the starting value
                        of of interval for initial condition y0
  --y0_end Y0_END       In the phase portait diagram, it is the final value
                        of intervalfor initial condition y0
  --y0_num_of_samples Y0_NUM_OF_SAMPLES
                        In the phase portait diagram, it is the number of samples
                        of initial condition y0 between y0_begin and y0_end
  --font_size FONT_SIZE
                        font size</code></pre>
			Dove:
			<ul>
				<li>
					<b>-h, --help</b>: mostra l&apos;usage del programma e termina l&apos;esecuzione.<br />
					<br />
				</li>
				<li>
					<b>--version</b>: mostra la versione del programma e termina l&apos;esecuzione.<br />
					<br />
				</li>
				<li>
					<b>--dx_dt</b>: espressione lambda della funzione $P(x,y)$.<br />
					Questa opzione obbligatoria.<br />
					<br />
				</li>
				<li>
					<b>--dy_dt</b>: espressione lambda della funzione $Q(x,y)$.<br />
					Questa opzione &egrave; obbligatoria.<br />
					<br />
				</li>
				<li>
					<b>--t_end</b>: intervallo della variabile $t$ tra 0 e t_end; (default 100.0).<br />
					Nel ritratto delle fasi, le traiettorie backward sono disegnate facendo variare il tempo tra -t_end e 0
					mentre le traiettorie forward sono disegnate facendo variare il tempo tra 0 e t_end.<br />
					<br />
				</li>
				<li>
					<b>--t_num_of_samples</b>: nel ritratto delle fasi &egrave; indica il numero di valori discreti di $t$ tra 0 e t_end per tracciare le traiettorie forward;
					analogamente, per le traiettorie backward, indica il numero di valori discreti di $t$  tra -t_end e 0; (default: 10).<br />
					<br />
				</li>
				<li>
					<b>--x0_begin</b> e <b>--x0_end</b>: nel ritratto delle fasi indica intervallo di variazione della condizione iniziale $x_0$; (default rispettivamente: -5.0 e 5.0).<br />
					<br />
				</li>
				<li>
					<b>--x0_num_of_samples</b>: nel ritratto delle fasi indica il numero di valori discreti di $x_0$ nell&apos;intervallo specificato dalla opzione precedente; (default: 6).<br />
					<br />
				</li>
				<li>
					<b>--y0_begin</b> e <b>--y0_end</b>: nel ritratto delle fasi indica intervallo di variazione della condizione iniziale $y_0$; (default rispettivamente: -5.0 e 5.0).<br />
					<br />
				</li>
				<li>
					<b>--y0_num_of_samples</b>: nel ritratto delle fasi indica il numero di valori discreti di $y_0$ nell&apos;intervallo specificato dalla opzione precedente; (default: 6).<br />
					<br />
				</li>
				<li>
					<b>--font_size</b>: dimensione del font di tutte le label presenti nelle figure generate dal programma; (default: 10).<br />
					<br />
				</li>
			</ul>
        </p>

		<h2>Esempi</h2>
		<p>
			Seguono una serie di esempi, tutti disponibili su GitHub a questo link <code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/">nonlin-auton-plane-sys-hartman-analyzer-examples</a></code>.<br />
			Alcuni di essi sono descritti in dettaglio qui di seguito, per altri vi &egrave; solo mostrato il ritratto delle fasi e si rimanda al corrispondente script su GitHub per la linea di comando.
		</p>
		
		<h3>Esempio n&deg; 01</h3>
		<p>
			Lo script shell di questo esempio &egrave; <code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_01.sh">example_01.sh</a></code>.
			Il sistema &egrave; costituito dalla seguente coppia di equazioni differenziali: 
            $$ \begin{equation}
            \begin{cases}
                x&apos; = x
                \\
                y&apos; = x^2 + y^2 - 1
            \end{cases}
            \end{equation} $$

			Per studiare il comportamento di tale sistema si esegua il comando: <pre><code>$ python nonlin-auton-plane-sys-hartman-analyzer.py \
    --dx_dt "x" \
    --dy_dt "x**2 + y**2 - 1" \
    --t_num_of_samples 500 \
    --x0_begin -3 --x0_end 3 \
    --y0_begin -3 --y0_end 3</pre></code>
			il cui output &egrave;:<br /><br />
			<pre><code class="shell">Critical point(s)         :  [(0, -1), (0, 1)]
Formal Jacobian           : 
⎡ 1    0 ⎤
⎢        ⎥
⎣2⋅x  2⋅y⎦
*************************   
Critical point            :  (0, -1)
Jacobian at c.p.          : 
⎡1  0 ⎤
⎢     ⎥
⎣0  -2⎦
Determinant               :  -2.0
Eigenvalues               :  1.0 -2.0
Eigenvector 1             :  [1.0, 0.0]
Eigenvector 2             :  [0.0, 1.0]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  saddle point
*************************   
Critical point            :  (0, 1)
Jacobian at c.p.          : 
⎡1  0⎤
⎢    ⎥
⎣0  2⎦
Determinant               :  2.0
Eigenvalues               :  1.0 2.0
Eigenvector 1             :  [1.0, 0.0]
Eigenvector 2             :  [0.0, 1.0]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  unstable node</code></pre>
			Da cui si evince che i punti critici sono finiti e sono due:
			$\left[\begin{matrix} 0 & -1 \end{matrix} \right]^\dag$ e $\left[\begin{matrix} 0 & 1 \end{matrix} \right]^\dag$.<br />
			Inoltre entrambi sono iperbolici e gli autovalori della matrice jacobiana calcolata nel punto $\left[\begin{matrix} 0 & -1 \end{matrix} \right]^\dag$ hanno segno discorde
			e quindi il primo punto critico &egrave; classificato come <em>punto sella</em>
			mentre gli autovalori della matrice jacobiana calcolata nel punto $\left[\begin{matrix} 0 & 1 \end{matrix} \right]^\dag$
			sono entrambi positivi, quindi il secondo punto critico &egrave; classificato come <em>nodo instabile</em>.<br />
			<br />
			Il ritratto delle fasi generato dal programma &egrave; il seguente:
		<p>
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_01.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_01.sh.</div>
        <br /><br />

		<h3>Esempi n&deg; 02, 03, 04</h3>
		<p>
			Per brevit&agrave; questi tre esempi non sono mostrati nel dettaglio. Gli script shell di questi tre esempi sono rispettivamente:<br />
			<code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_02.sh">example_02.sh</a></code>&nbsp;
			<code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_03.sh">example_03.sh</a></code>&nbsp;
			<code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_04.sh">example_04.sh</a></code><br />
			I ritratti delle fasi generati dal programma sono rispettivamente:
		<p>
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_02.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_02.sh.</div>
        <br /><br />
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_03.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_03.sh.</div>
        <br /><br />
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_04.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_04.sh.</div>
        <br /><br />

		<h3>Esempio n&deg; 05 epidemia</h3>
		<p>
			Questo esempio descrive un semplice modello di diffusione di un&apos;epidemia in una citt&agrave;.
			Anche questo esempio per brevit&agrave; non &egrave; mostrato in dettaglio; il corrispondente script shell &egrave;
			<code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_05_epidemic.sh">example_05_epidemic.sh</a></code><br />
			Il ritratto delle fasi generato dal programma &egrave; il seguente:
		<p>
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_05_epidemic.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_05_epidemic.sh.</div>
        <br /><br />

		<h3>Esempio n&deg; 06 specie infettata</h3>
		<p>
			Questo esempio descrive l&apos;evolversi di una popolazione di animali sani di una specie, rappresentati dalla variabile $x$,
			e la sottopopolazione di animali infetti, rappresentanti dalla variabile $y$, che non guariscono mai una volta infettati,
			entrambe misurate in milioni di esemplari.<br />
			<br />
			Lo script shell di questo esempio &egrave; <code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_06_infected_species.sh">example_06_infected_species.sh</a></code>.
			Il sistema &egrave; costituito dalla seguente coppia di equazioni differenziali: 
            $$ \begin{equation}
            \begin{cases}
                x&apos; = (b-d)x - \delta y & b=4, d=1, \delta=6
                \\
                y&apos; = \tau y (x - y) - (\delta + d) y & \tau = 1
            \end{cases}
            \end{equation} $$

			Per studiare il comportamento di tale sistema si esegua il comando: <pre><code>$ python nonlin-auton-plane-sys-hartman-analyzer.py \
     --dx_dt "(4.0 - 1.0) * x - 6.0 * y" \
    --dy_dt "1.0 * y * (x - y) - (6.0 + 1.0) * y" \
    --t_num_of_samples 500 \
    --x0_begin 0 --x0_end 20 \
    --y0_begin 0 --y0_end 20</pre></code>
			il cui output &egrave;:<br /><br />
			<pre><code class="shell">Critical point(s)         :  [(0.0, 0.0), (14.0, 7.0)]
Formal Jacobian           : 
⎡ 3.0          -6.0        ⎤
⎢                          ⎥
⎣1.0⋅y  1.0⋅x - 2.0⋅y - 7.0⎦
*************************   
Critical point            :  (0.0, 0.0)
Jacobian at c.p.          : 
⎡3.0  -6.0⎤
⎢         ⎥
⎣0.0  -7.0⎦
Determinant               :  -21.0
Eigenvalues               :  3.0 -7.0
Eigenvector 1             :  [1.0, 0.0]
Eigenvector 2             :  [0.5144957554275265, 0.8574929257125441]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  saddle point
*************************   
Critical point            :  (14.0, 7.0)
Jacobian at c.p.          : 
⎡3.0  -6.0⎤
⎢         ⎥
⎣7.0  -7.0⎦
Determinant               :  21.0
Eigenvalues               :  (-2+4.12310562j) (-2-4.12310562j)
Eigenvector 1             :  [(0.52414241+0.43221891j), (0.73379938+0j)]
Eigenvector 2             :  [(0.52414241-0.43221891j), (0.73379938-0j)]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  stable focus</code></pre>
			Da cui si evince che i punti critici sono finiti e sono due:
			$\left[\begin{matrix} 0 & 0 \end{matrix} \right]^\dag$ e $\left[\begin{matrix} 14 & 7 \end{matrix} \right]^\dag$.<br />
			Inoltre entrambi sono iperbolici e gli autovalori della matrice jacobiana calcolata nel punto $\left[\begin{matrix} 0 & 0 \end{matrix} \right]^\dag$ hanno segno discorde
			e quindi il primo punto critico &egrave; classificato come <em>punto sella</em>
			mentre gli autovalori della matrice jacobiana calcolata nel punto $\left[\begin{matrix} 14 & 7 \end{matrix} \right]^\dag$
			sono complessi coniugati con parte reale negativa, quindi il secondo punto critico &egrave; classificato come <em>focus stabile</em>.<br />
			<br />
			Il ritratto delle fasi generato dal programma &egrave; il seguente:
		<p>
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_06_infected_species.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_06_infected_species.sh.</div>
        <br /><br />

		<h3>Esempio n&deg; 07 specie in competizione</h3>
		<p>
			Questo esempio descrive un semplice di due specie in competizione tra loro in un ambiente in cui l&apos;approvvigionamento alimentare comune &egrave; limitato.
			Anche questo esempio per brevit&agrave; non &egrave; mostrato in dettaglio; il corrispondente script shell &egrave;
			<code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_07_competing_species.sh">example_07_competing_species.sh</a></code><br />
			Il ritratto delle fasi generato dal programma &egrave; il seguente:
		<p>
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_07_competing_species.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_07_competing_species.sh.</div>
        <br /><br />

		<h3>Esempio n&deg; 08 Lotka-Volterra</h3>
		<p>
			Questo esempio descrive la dinamica di un ecosistema in cui interagiscono soltanto due specie animali: una delle due come predatore (modellata dalla variabile $y$),
			l&apos;altra come la sua preda (modellata dalla variabile $x$) in accordo con il sistema pubblicato da Lotka nel 1925 e indipendentemente da Volterra nel 1926.<br />
			<br />
			Lo script shell di questo esempio &egrave; <code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_08_lotka_volterra.sh">example_08_lotka_volterra.sh</a></code>.
			Il sistema &egrave; costituito dalla seguente coppia di equazioni differenziali: 
            $$ \begin{equation}
            \begin{cases}
                x&apos; = x (A - By) & A=\frac{2}{3}, B=\frac{4}{3}
                \\
                y&apos; = y (Cx - D) & C=\frac{9}{10}, D=\frac{9}{10}
            \end{cases}
            \end{equation} $$

			Per studiare il comportamento di tale sistema si esegua il comando: <pre><code>$ python nonlin-auton-plane-sys-hartman-analyzer.py \
    --dx_dt "x * (0.666 - 1.333 * y)" \
    --dy_dt "y * (0.9 * x - 0.9)" \
    --t_num_of_samples 500 \
    --x0_begin 0 --x0_end 4 \
    --y0_begin 0 --y0_end 2</pre></code>
			il cui output &egrave;:<br /><br />
			<pre><code class="shell">Critical point(s)         :  [(0.0, 0.0), (1.0, 0.499624906226557)]
Formal Jacobian           : 
⎡0.666 - 1.333⋅y   -1.333⋅x  ⎤
⎢                            ⎥
⎣     0.9⋅y       0.9⋅x - 0.9⎦
*************************   
Critical point            :  (0.0, 0.0)
Jacobian at c.p.          : 
⎡0.666  0.0 ⎤
⎢           ⎥
⎣ 0.0   -0.9⎦
Determinant               :  -0.5994
Eigenvalues               :  0.666 -0.9
Eigenvector 1             :  [1.0, 0.0]
Eigenvector 2             :  [0.0, 1.0]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  saddle point
*************************   
Critical point            :  (1.0, 0.499624906226557)
Jacobian at c.p.          : 
⎡-4.44089209850063e-16  -1.333⎤
⎢                             ⎥
⎣  0.449662415603901     0.0  ⎦
Determinant               :  0.5994000000000004
Eigenvalues               :  (0+0.77420927j) (0-0.77420927j)
Eigenvector 1             :  [(-0.86472998+0j), (0+0.50223704j)]
Eigenvector 2             :  [(-0.86472998-0j), (0-0.50223704j)]
Type of c.p.              :  Non-hyperbolic
	So Hartman theorem cannot be applied to this critical point</code></pre>
			Da cui si evince che i punti critici sono finiti e sono due, ma il secondo &egrave; non iperbolico,
			quindi il programma analizza solamente il punto critico iperbolico $\left[\begin{matrix} 0 & 0 \end{matrix} \right]^\dag$
			e gli autovalori della matrice jacobiana calcolata in tale punto hanno segno discorde
			e quindi esso &egrave; classificato come <em>punto sella</em>.<br />
			<br />
			Il ritratto delle fasi generato dal programma &egrave; il seguente:
		<p>
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_08_lotka_volterra.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_08_lotka_volterra.sh.</div>
        <br /><br />

		<h3>Esempi n&deg; 09 e 10 Holling-Tanner</h3>
		<p>
			Questa coppia di esempi descrive come il precedente una dinamica di un ecosistema in cui interagiscono soltanto due specie animali: una delle due come predatore (modellata dalla variabile $y$),
			l&apos;altra come la sua preda (modellata dalla variabile $x$), ma seguendo un sistema di equazioni differente, detto di Holling-Tanner.<br />
			<br />
			Gli script shell di questa coppia di esempi sono <code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_09_holling_tanner_0dot5.sh">example_09_holling-tanner_0_dot5.sh</a></code> e
			<code><a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer-examples/example_10_holling_tanner_2dot5.sh">example_10_holling_tanner_2dot5.sh</a></code>.
			Il sistema &egrave; costituito dalla seguente coppia di equazioni differenziali: 
            $$ \begin{equation}
            \begin{cases}
                x&apos; = x (1 - \frac{x}{7}) - \frac{6xy}{7 + 7x}
                \\
                y&apos; = 0.2 y (1 - \frac{Ny}{x})
            \end{cases}
            \end{equation} $$

			e i due esempi differiscono solo per la costante $N$ che vale $0.5$ per il primo e $2.5$ per il secondo.<br />
			<br />
			Per studiare il comportamento di tale sistema per $N=0.5$ si esegua il comando: <pre><code>$ python nonlin-auton-plane-sys-hartman-analyzer.py \
    --dx_dt "x * (1 - x/7) - 6*x*y/(7+7*x)" \
    --dy_dt "0.2*y * (1 - (0.5*y)/x)" \
    --t_num_of_samples 500 \
    --x0_begin 0 --x0_end 8 \
    --y0_begin 0 --y0_end 6</pre></code>
			il cui output &egrave;:<br /><br />
			<pre><code class="shell">Critical point(s)         :  [(-7.0, -14.0), (1.0, 2.0), (7.0, 0.0)]
Formal Jacobian           : 
⎡  42⋅x⋅y     2⋅x     6⋅y           -6⋅x    ⎤
⎢────────── - ─── - ─────── + 1    ───────  ⎥
⎢         2    7    7⋅x + 7        7⋅x + 7  ⎥
⎢(7⋅x + 7)                                  ⎥
⎢                                           ⎥
⎢                 2                         ⎥
⎢            0.1⋅y                     0.2⋅y⎥
⎢            ──────              0.2 - ─────⎥
⎢               2                        x  ⎥
⎣              x                            ⎦
*************************   
Critical point            :  (-7.0, -14.0)
Jacobian at c.p.          : 
⎡3.33333333333333  -1.0⎤
⎢                      ⎥
⎣      0.4         -0.2⎦
Determinant               :  -0.2666666666666668
Eigenvalues               :  3.2162457375544835 -0.08291240422114961
Eigenvector 1             :  [0.9932149332261002, 0.11629314862309552]
Eigenvector 2             :  [0.28093063252715217, 0.9597280759193689]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  saddle point
*************************   
Critical point            :  (1.0, 2.0)
Jacobian at c.p.          : 
⎡0.285714285714286  -0.428571428571429⎤
⎢                                     ⎥
⎣       0.4                -0.2       ⎦
Determinant               :  0.11428571428571427
Eigenvalues               :  (0.04285714+0.33533413j) (0.04285714-0.33533413j)
Eigenvector 1             :  [(0.71919495+0j), (0.40754380-0.56273143j)]
Eigenvector 2             :  [(0.71919495-0j), (0.40754380+0.56273143j)]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  unstable focus
*************************   
Critical point            :  (7.0, 0.0)
Jacobian at c.p.          : 
⎡-1.0  -0.75⎤
⎢           ⎥
⎣0.0    0.2 ⎦
Determinant               :  -0.2
Eigenvalues               :  -1.0 0.2
Eigenvector 1             :  [1.0, 0.0]
Eigenvector 2             :  [-0.52999894000318, 0.847998304005088]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  saddle point</code></pre>
			<br /><br />
			Per studiare il comportamento di tale sistema per $N=2.5$ si esegua il comando:<br /><br /><pre><code>$ python nonlin-auton-plane-sys-hartman-analyzer.py \
    --dx_dt "x * (1 - x/7) - 6*x*y/(7+7*x)" \
    --dy_dt "0.2*y * (1 - (2.5*y)/x)" \
    --t_num_of_samples 500 \
    --x0_begin 0 --x0_end 8 \
    --y0_begin 0 --y0_end 6</pre></code>
			il cui output &egrave;:<br /><br />
			<pre><code class="shell">Critical point(s)         :  [(-1.4, -0.56), (5.0, 2.0), (7.0, 0.0)]
Formal Jacobian           : 
⎡  42⋅x⋅y     2⋅x     6⋅y         -6⋅x  ⎤
⎢────────── - ─── - ─────── + 1  ───────⎥
⎢         2    7    7⋅x + 7      7⋅x + 7⎥
⎢(7⋅x + 7)                              ⎥
⎢                                       ⎥
⎢                 2                     ⎥
⎢            0.5⋅y                     y⎥
⎢            ──────              0.2 - ─⎥
⎢               2                      x⎥
⎣              x                        ⎦
*************************   
Critical point            :  (-1.4, -0.56)
Jacobian at c.p.          : 
⎡4.4   -3.0⎤
⎢          ⎥
⎣0.08  -0.2⎦
Determinant               :  -0.640000000000001
Eigenvalues               :  4.347220505424427 -0.14722050542442328
Eigenvector 1             :  [0.9998452761917251, 0.017590442777059078]
Eigenvector 2             :  [0.5506931674648844, 0.8347077544311499]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  saddle point
*************************   
Critical point            :  (5.0, 2.0)
Jacobian at c.p.          : 
⎡-0.476190476190476  -0.714285714285714⎤
⎢                                      ⎥
⎣       0.08                -0.2       ⎦
Determinant               :  0.15238095238095234
Eigenvalues               :  (-0.33809523+0.19512191j) (-0.33809523-0.19512191j)
Eigenvector 1             :  [(0.94830405+0j), (-0.18333878-0.25904886j)]
Eigenvector 2             :  [(0.94830405-0j), (-0.18333878+0.25904886j)]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  stable focus
*************************   
Critical point            :  (7.0, 0.0)
Jacobian at c.p.          : 
⎡-1.0  -0.75⎤
⎢           ⎥
⎣0.0    0.2 ⎦
Determinant               :  -0.2
Eigenvalues               :  -1.0 0.2
Eigenvector 1             :  [1.0, 0.0]
Eigenvector 2             :  [-0.52999894000318, 0.847998304005088]
Type of c.p.              :  Hyperbolic
Kind of critical point(s) :  saddle point</code></pre>
			I ritratti delle fasi generati dal programma sono i seguenti:
		<p>
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_09_holling_tanner_0dot5.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_09_holling_tanner_0dot5.sh.</div>
        <br /><br />
        <div class="betweentextlines"><img src="../../posts/mathematics/analyzer-of-a-nonlinear-autonomous-dynamical-system-on-plane-by-hartman-grobman-theorem/annlinauphart_10_holling_tanner_2dot5.png" /></div>
        <div class="photocaption">Il ritratto delle fasi di example_10_holling_tanner_2dot5.sh.</div>
        <br /><br />

        <h2>Bibliografia</h2>
        <p>
            <pre><code class="text">Stephen Lynch
<i><a target="_blank" href="https://www.springer.com/gp/book/9783319781440">Dynamical Systems with Applications using Python</a></i>
Springer
2018</code></pre>
        </p>

        <h2 id="downloadcode">Download del codice completo</h2>
		<p>
			Il codice completo &egrave; disponibile su <a target="_blank" href="https://github.com/ettoremessina/differential-equations/blob/main/ODEs/dyn-sys/python/nonlin-auton-plane-sys-hartman-analyzer.py">GitHub</a>.
			<br/>
			
			Questo materiale &egrave; distribuito su licenza MIT; sentiti libero di usare, condividere, &quot;forkare&quot; e adattare tale materiale come credi.
			<br/>
			Sentiti anche libero di pubblicare pull-request e bug-report su questo repository di GitHub oppure di contattarmi sui miei canali social disponibili nell&apos;angolo in alto a destra di questa pagina. 
			<br/>

		</p>
	</section>

						</div>
				</div>
				<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">
							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<div class="align-center"><img src="../../images/cm-logo-small.png" alt="Mentalit&agrave;&nbsp;Computazionale"/></div>
										<h2>Menu</h2>
									</header>
									<ul>
										<li><a href="../../it/">Home</a></li>
										<li>
											<span class="opener">Reti&nbsp;Neurali</span>
											<ul>
												<li><a href="../../it/reti-neurali/">INDICE</a></li>
												<li><a href="../../it/reti-neurali/pruning-di-reti-neurali-con-tensorflow.html">Pruning di reti neurali con TensorFlow</a></li>
												<li><a href="../../it/reti-neurali/equazioni-differenziali-e-reti-neurali.html">Equazioni Differenziali e Reti Neurali</a></li>
												<li><a href="../../it/reti-neurali/forecast-di-una-serie-temporale-univariata-equispaziata-con-tensorflow.html">Forecast di una serie temporale univariata ed equispaziata con TensorFlow</a></li>
												<li><a href="../../it/reti-neurali/approssimazione-con-percettroni-multistrato-altamente-configurabili.html">Approssimazione con percettroni multistrato altamente configurabili</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Computazione&nbsp;Quantistica</span>
											<ul>
												<li><a href="../../it/computazione-quantistica/">INDICE</a></li>
												<li><a href="../../it/computazione-quantistica/operatori-not-cnot.html">Porte quantistiche NOT e C-NOT</a></li>
												<li><a href="../../it/computazione-quantistica/generazione-numero-casuale.html">Generazione di un numero casuale</a></li>
												<li><a href="../../it/computazione-quantistica/porte-hadamard-in-cascata.html">Porte Hadamard in cascata</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Machine&nbsp;Learning</span>
											<ul>
												<li><a href="../../it/machine-learning/">INDICE</a></li>
												<li><a href="../../it/machine-learning/strumenti-generali-per-approssimazione-di-funzioni.html">Strumenti generali per l&apos;approssimazione di funzioni</a></li>
												<li><a href="../../it/machine-learning/approssimazione-di-funzioni-con-pycaret.html">Approssimazione di funzioni tramite PyCaret</a></li>
												<li><a href="../../it/machine-learning/approssimazione-di-funzioni-con-xgboost-configurabile.html">Approssimazione di funzioni tramite un regressore XGBoost configurabile</a></li>
												<li><a href="../../it/machine-learning/approssimazione-di-funzioni-con-svr-configurabile.html">Approssimazione di funzioni tramite un Support Vector Regressor configurabile</a></li>
												<li><a href="../../it/machine-learning/regressione-polinomiale-con-accord-net.html">Regressione polinomiale con Accord.NET</a></li>
												<li><a href="../../it/machine-learning/regressione-smo-con-kernel-puk-in-weka.html">Regressione con SMO per SVM con kernel PUK in Weka</a></li>
												<li><a href="../../it/machine-learning/forecast-smo-con-kernel-polinomiale-in-weka.html">Forecast con SMO per SVM con kernel polinomiale in Weka</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Matematica</span>
											<ul>
												<li><a href="../../it/matematica/">INDICE</a></li>
												<li><a href="../../it/matematica/serie-di-fourier-in-python.html">Serie di Fourier in Python</a></li>
												<li><a href="../../it/matematica/risoluzione-equazioni-differenziali-con-ritardo-in-python-con-metodi-numerici.html">Risoluzione di equazioni differenziali con ritardo con metodi numerici in Python</a></li>
												<li><a href="../../it/matematica/calcolo-integrale-in-python.html">Calcolo Integrale in Python</a></li>
												<li><a href="../../it/matematica/analizzatore-di-un-sistema-dinamico-sul-piano-lineare-omogeneo-coefficienti-costanti.html">Analizzatore di un sistema dinamico, lineare e omogeneo sul piano a coefficienti costanti</a></li>
												<li><a href="../../it/matematica/analizzatore-di-un-sistema-dinamico-non-lineare-autonomo-sul-piano-tramite-teorema-hartman-grobman.html">Analizzatore di un sistema dinamico non lineare e autonomo sul piano tramite il teorema di Hartman-Grobman</a></li>
												<li><a href="../../it/matematica/esperimenti-con-sympy-per-risolvere-odes-ordine-1.html">Esperimenti con SymPy per risolvere equazioni differenziali ordinarie del 1&deg; ordine</a></li>
												<li><a href="../../it/matematica/metodo-soluzione-dde-primo-ordine-usando-funzione-w-lambert.html">Un metodo di soluzione di una equazione differenziale con ritardo del primo ordine utilizzando la funzione W di Lambert</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">High Performance</span>
											<ul>
												<li><a href="../../it/high-performance/">INDICE</a></li>
												<li><a href="https://ettoremessina.tech/2024/09/14/high-performance-computing-of-discrete-single-variable-derivative-with-cuda/" target="_blank">High-Performance Computing of Discrete Single Variable Derivative with CUDA<br />
(post disponibile solo in lingua inglese)</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Dataset</span>
											<ul>
												<li><a href="../../it/datasets/">INDICE</a></li>
												<li><a href="../../it/datasets/functions-dataset.html">Collezione di dataset &apos;Functions&apos;</a></li>
												<li><a href="../../it/datasets/time-series-dataset.html">Collezione di dataset &apos;Time&nbsp;Series&apos;</a></li>
												<li><a href="../../it/datasets/synthetic-words-dataset.html">Dataset &apos;Synthetic Words&apos;</a></li>
											</ul>
										</li>
										<li><a href="../../it/info.html">Info</a></li>
									</ul>
								</nav>

							<!-- Section -->
								<section>
                                    <div class="side-topics">
                                        <header class="align-center">
                                            <h2><a href="../../it/reti-neurali/">Reti&nbsp;Neurali</a></h2>
                                        </header>
                                        <article>
                                            <a href="../../it/reti-neurali/" class="image"><span class="icon solid fa-sitemap"/></a>
                                        </article>
                                        <header class="align-center">
                                            <h2><a href="../../it/computazione-quantistica/">Computazione&nbsp;Quantistica</a></h2>
                                        </header>
                                        <article>
                                            <a href="../../it/computazione-quantistica/" class="image"><span class="icon solid fa-atom"/></a>
                                        </article>
                                    </div>
								</section>

							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">
										Grafica basata sul template &apos;Editorial&apos; (con personalizzazione) scaricato da <a href="https://html5up.net" target="_blank">HTML5 UP</a>.
										<br/>
										Clicka sui link per vedere i file <a href="../../html5up-license/LICENSE.txt" target="_blank">LICENSE.txt</a> e <a href="../../html5up-license/README.txt" target="_blank">README.txt</a> del template &apos;Editorial&apos; di HTML5 UP.
										<br>
										<br>
										&copy; <a href="../../it/info.html">Ettore Messina</a>. 
									</p>
								</footer>
						</div>
					</div>
			</div>

		<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/browser.min.js"></script>
			<script src="../../assets/js/breakpoints.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<script src="../../assets/js/main.js"></script>

			<style>
				a.cc-link
				{
			    	border-bottom: none;
				}
				a.cc-link:hover
				{
					color: white !important;
				}
			</style>
	</body>
</html>

